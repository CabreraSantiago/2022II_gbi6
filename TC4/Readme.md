# Clase 4
## Ejercicio 10.1
En el Ejercicio 10.1, tuvimos que cambiar de directorio utilizando cd para encontrar el archivo Marra_data.fasta, que se encuentra en el directorio CSB-master/unix/sandbox. Una vez que encontramos el archivo, anotamos su ubicación y luego ejecutamos el comando du -h, que nos permite conocer el espacio de disco utilizado por los directorios y archivos. A continuación, utilizamos cp para crear una copia de *mi_archivo.fasta en la caja de arena y la ejecutamos de nuevo para su inspección. A continuación, contamos el número de clasificaciones del isogrupo00036. Para ello se utilizó el comando grep -c <>, que contó el número de apariciones de la palabra en el archivo. El contenido del archivo estaba separado por dos espacios, por lo que había que sustituir los espacios por comas. Para ello se utilizaron los comandos cat, tr -s y head -n, que enumeran los cambios realizados por el comando tr, que combina el espacio y la coma, y head ayudó a mostrar la mayor parte de la información necesaria para confirmar el uso correcto del comando, pero no fue posible guardarlo directamente en el archivo mi_fichero. fasta, por lo que hubo que crear un archivo temporal porque el archivo de interés se redirigió al proceso redirigido en lugar de a la salida de todo el pipeline. En el paso 6 se nos pidió que contáramos los isogrupos, para lo cual utilizamos el comando grep '>', que nos permitió mostrar la información de cada fila y columna, por lo que pudimos excluir la columna 4 y contar los isogrupos fila por fila. Por último, volvimos a utilizar grep '>' para escanear la información del archivo, de modo que recortamos las columnas con mayor número de lecturas y las columnas con mayor número de lecturas, pero las ordenamos de mayor a menor para saber qué contenedor contenía más lecturas.
## Ejercicio 10.2
En este ejercicio, teníamos que localizar un archivo, y lo hicimos utilizando el comando grep -r, que nos permitió encontrar el archivo en las carpetas. Después de encontrar la ruta usamos cd para cambiar el directorio, este archivo fue encontrado en los datos. La cabecera se utiliza para mostrar información sobre el archivo. A continuación, recortamos la columna 1, que contenía los identificadores, y utilizamos grep -c -w para contar el tiempo que se tardaba en registrar a los individuos 3 y 27, donde -w sólo nos permitía encontrar a los individuos 3 y 27. A continuación, necesitábamos un script que aceptara el nombre del archivo y el identificador como entrada, que sólo permitiera introducir el identificador, y que proporcionara los tiempos registrados como salida, y para ello utilizamos el archivo count_baboons.sh, que contenía un script que permitía introducir el identificador y proporcionaba los tiempos registrados. Por último, escribimos otra secuencia de comandos que mostraba el número de veces que muestreábamos a cada individuo. Para ello, utilizamos un bucle en el que los datos del archivo no se almacenaban primero en una variable que contenía columnas de identificadores únicos ordenados de menor a mayor. En el bucle for, utilizamos la variable creada para los identificadores, y en la siguiente variable, mycounts, especificamos un comando para ejecutar count_baboons.sh, y utilizamos echo para ejecutar el comando en el bucle.
## Ejercicio 10.3
Nuevamente, se cambió el directorio mediante cd a la carpeta Saavedra2013. Aquí se pidió un script que tomara como entrada uno de los archivos de la carpeta y mediante el mismo script se pudo determinar el número de líneas. Para ello, tuvimos que crear otro fichero llamado scriptconcatenado.sh en el que colocamos un echo para imprimir el nombre del fichero identificado como $1, colocamos otro echo para imprimir el número de líneas y un cat para mostrar el contenido creado, que en este caso era el número de líneas que contenía cada fichero, añadimos otro echo para imprimir la información del número de columnas y un head para mostrar una línea enlazada con un tr -d para eliminar el espacio entre las columnas y poder contarlas. Una vez que el archivo de script estuvo listo, se ejecutó con un *bash* junto con el archivo que quería saber el número de filas y columnas. Del mismo modo, se creó otro script para imprimir el número de filas y columnas de cada archivo. Pero primero había que añadir todos los archivos a una variable para facilitar la interacción con todos los archivos. Después implementamos un for y dentro de él dimos el comando para imprimir el número de filas, cuyo comando estaba en otra variable mifila, de igual manera para contar las columnas anexamos un head, tr -d y wc -c para dar el número de columnas presentes en los archivos. Y finalmente se ejecutó un bash que implementó el archivo scriptconcatenado2.sh, que tenía el script de bucle para ordenar los archivos con las filas y columnas más altas y con esto se conoció el archivo con el mayor número de filas y columnas.

